# 魔法JS☆あれい 第3話「もうsortもreverseも怖くない」

登場人物

丹生（にゅう）あれい
魔法少女「魔法（マジカル）JS（女子小学生）☆あれい」として活動中。

イテレー太  
正体不明の魔法生物。

* [第1話「popでpushした、ような……」](https://qiita.com/8amjp/items/e44e707ccc8c95b4a40d)
* [第2話「shiftはとってもunshiftって」](https://qiita.com/8amjp/items/3fc1b2defd28ba1c2df3)

## sort()

イテレー太「あれい、状況説明をサボるけど、今戦闘の真っ最中だよ！」
あれい「ついにサボると言い出したなこの駄犬」
イ「そしていつものように、僕が魔法世界から召喚したデータを、あれいの配列魔法を使って、敵の弱点に合わせた値に変換して`return`する事で、ダメージを与えて敵を倒してよ！」
あ「そこだけはセリフが説明的なんだよな」
イ「さて、今回僕が魔法世界から召喚したデータは……これだよ！」

```
items = [
  { name: '越前おろしそば', price: 650 },
  { name: '海老天おろしそば', price: 1100 },
  { name: 'あげおろしそば', price: 850 },
  { name: 'とろろおろしそば', price: 800 },
];
```

あ「あー、今度は福井の蕎麦屋のメニューか」
イ「そして、今回の敵の弱点は、『要素の`price`の値が低い順に並んだ配列』だよ！」
あ「なんなんだよその弱点。あと第3話にして急に難度が上がってないか」
イ「さあ、あれいの配列魔法で、安い順に並んだメニューを`return`して倒してよ！」
あ「面倒くせえなあ……」

```
items.sort((a, b) => a.price - b.price); 
```

あ「これでいいのか」
イ「あれい、もうちょっと試行錯誤して盛り上がろうよ」

### 解説

> 配列の要素を_[in place](https://ja.wikipedia.org/wiki/In-place%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0)で_ソートします。このソートは [stable](https://en.wikipedia.org/wiki/Sorting_algorithm#Stability) ではありません(訳注:同じ序列を持つ値の順番が保証されません)。 デフォルトではUnicodeコードポイントの昇順にソートされます。

（[MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)より）

`sort()`メソッドは、その名の通り、配列の要素をルールに基づいて並べ替えます。
引数無しで`sort()`メソッドを実行した場合、配列の要素は値の小さい順（昇順）に並べ替えられますが、具体的には下記の比較関数の戻り値によって順番が判定されます。

```
items.sort((a, b) => a < b ? -1 : a > b ? 1 : 0); 
```

まず要素の中から2つを選び、値を比較します。`a`が比較対象の`b`より小さければ順位が上、大きければ順位が下、同じならば同点として判定します。これをひたすら繰り返すことにより、すべての要素が順番に並べ替えられます。

しかし、今回の例のような階層構造の配列の場合、この方法では大小を判定できないため、意図どおりに並べ替えることができません。そういう場合は、比較関数

```
items.sort((a, b) => a.price < b.price ? -1 : a.price > b.price ? 1 : 0); 
```

で、比較対象が単純な数値であれば、下記のように簡単に記述することができます。

```
items.sort((a, b) => a.price - b.price); 
```



## reverse()

イ「では、続いての敵にいってみましょう」
あ「ラジオパーソナリティーかよ」
イ「さて、僕が魔法世界から召喚したデータは、今こんな状態になっているよ！」

```
items = ['越前おろしそば', 'ソースカツ丼'];
```

あ「そうだな」
イ「そして、新たに魔法世界から召喚したデータは、これだ！」

```
newItems = ['ボルガライス', 'へしこパスタ'];
```

イ「このデータを……」
あ「元の配列の最初に追加した上で、その最初の要素を敵にぶつけりゃいいのか？」
イ「……なんでそんな無駄なことするの？」
あ「お前が前回そうしろっつったんだろ！　お前にボルガライスぶつけるぞ！」
イ「まあまあ。今回は、元の配列の最初に追加して、その配列の要素数を`return`すればいいよ！」
あ「面倒くせえなあ……」

```
return items.reverse();
```

あ「これでいいのか」
イ「あ、簡単にできたね」

### 解説

> 配列の要素を _[In-place アルゴリズム](https://ja.wikipedia.org/wiki/In-place%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0)_ で反転させます。最初の要素は最後に、最後の要素は最初になります。

（[MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)より）

つまり、行列の一番前に、何人かが割り込みするようなイメージです。とても理不尽ですね。
また、このメソッドの戻り値は、`push()`メソッドと同じく、新しい配列の要素の数になります。

----
さて、魔法JS☆あれいは、魔法（JavaScript）の力でこの世界を守ることが出来るのか！？　次回に続く！
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTc3MjE5NDA1NywtMTk5OTYxNDgzLC04Nz
QxMTQxNDcsMTY0MjUyNTI4MiwtMzYzODYwNDEsLTIxMDYxMTQ2
MDgsNTI0NjEwNjcxLC0xMzg3MDU2MTUzXX0=
-->